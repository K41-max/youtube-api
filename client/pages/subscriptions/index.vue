<script setup lang="ts">
import EditIcon from 'vue-material-design-icons/PencilBoxMultipleOutline.vue';
import SubscriptionIcon from 'vue-material-design-icons/YoutubeSubscription.vue';
import ImportIcon from 'vue-material-design-icons/Import.vue';
import SubscriptionImport from '@/components/popup/SubscriptionImport.vue';
import VideoEntry from '@/components/list/VideoEntry.vue';
import Spinner from '@/components/Spinner.vue';
import SectionTitle from '@/components/SectionTitle.vue';
import SwitchButton from '@/components/buttons/SwitchButton.vue';
import BadgeButton from '@/components/buttons/BadgeButton.vue';
import Pagination from '@/components/pagination/Pagination.vue';
import { useMessagesStore } from '~/store/messages';
import { useUserStore } from '~~/store/user';

const messagesStore = useMessagesStore();
const userStore = useUserStore();
const config = useRuntimeConfig();
const route = useRoute();

const vapidKey = config.public.vapidKey;

const notificationsEnabled = ref(false);
const notificationsBtnDisabled = ref(false);
const notificationsSupported = ref(true);
const subscriptionImportOpen = ref(false);
const currentPage = ref(1);

const {
  data: subscriptions,
  pending,
  error,
  refresh
} = useGetUserSubscriptions({
  limit: 20,
  start: (currentPage.value - 1) * 30
});

const videos = computed(() => subscriptions.value?.videos ?? []);
const pageCount = computed(() => Math.ceil((subscriptions.value?.videoCount ?? 30) / 30));
const hasNoSubscriptions = computed(() => {
  return !getOrderedVideoSections() || getOrderedVideoSections().length <= 0;
});
const lastRefreshTime = computed(() => subscriptions.value?.lastRefresh ?? 0);

watch(error, err => {
  messagesStore.createMessage({
    type: 'error',
    title: 'Error loading subscription feed',
    message: err?.message ?? 'Error loading subscription feed'
  });
});

const getOrderedVideoSections = (): Array<any> => {
  const orderedArray = [];
  let i = 0;
  videos.value.forEach(video => {
    let sectionMessage = 'Older videos';
    const now = new Date();
    if (video.published > now.valueOf() - 604800000) {
      sectionMessage = 'Last 7 days';
    }
    if (video.published > now.valueOf() - 172800000) {
      sectionMessage = 'Yesterday';
    }
    if (video.published > now.valueOf() - 86400000) {
      sectionMessage = 'Today';
    }
    const possibleIndex = orderedArray.findIndex(el => el.sectionMessage === sectionMessage);
    if (possibleIndex !== -1) {
      orderedArray[possibleIndex].videos.push(video);
    } else {
      orderedArray.push({ sectionMessage, videos: [video], id: i++ });
    }
  });
  return orderedArray;
};

const closeSubscriptionImport = () => {
  subscriptionImportOpen.value = false;
};
const onSubscriptionImportDone = () => {
  refresh();
};
const subscribeToNotifications = (val: any) => {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then(registrations => {
      const worker = registrations[0];

      if (val) {
        worker.pushManager
          .subscribe({
            userVisibleOnly: true,
            applicationServerKey: vapidKey.value
          })
          .then(subscription => {
            $fetch(`${config.public.apiUrl}user/notifications/subscribe`, {
              method: 'POST',
              body: subscription,
              credentials: 'include'
            }).then(() => {
              notificationsEnabled.value = true;
            });
          })
          .catch(err => {
            notificationsEnabled.value = false;
            notificationsBtnDisabled.value = true;
            messagesStore.createMessage({
              type: 'error',
              title: 'Error subscribing to notifications',
              message: err.message
            });
          });
      } else {
        worker.pushManager.getSubscription().then((subscription: PushSubscription) => {
          if (subscription) {
            subscription.unsubscribe();
          }
          notificationsEnabled.value = false;
        });
      }
    });
  }
};
const getNotificationStatus = () => {
  if (notificationsBtnDisabled.value && notificationsEnabled.value) {
    return 'Notifications are enabled';
  } else if (notificationsSupported.value) {
    return 'Notifications are not supported';
  } else if (!notificationsBtnDisabled.value && !notificationsEnabled.value) {
    return 'Notifications are disabled';
  }
};

onMounted(() => {
  if (vapidKey.value && 'serviceWorker' in navigator) {
    navigator.serviceWorker
      .getRegistrations()
      .then(registrations => {
        const worker = registrations[0];
        if (worker) {
          worker.pushManager
            .permissionState({
              userVisibleOnly: true,
              applicationServerKey: vapidKey.value
            })
            .then(permissionState => {
              if (permissionState === 'granted') {
                notificationsEnabled.value = true;
              } else if (permissionState === 'denied') {
                notificationsEnabled.value = false;
                notificationsBtnDisabled.value = true;
              }
            });
        } else {
          notificationsEnabled.value = false;
          notificationsBtnDisabled.value = true;
        }
      })
      .catch(err => {
        messagesStore.createMessage({
          type: 'error',
          title: 'Error loading notification worker',
          message: err.message
        });
      });
  } else {
    notificationsSupported.value = false;
    notificationsBtnDisabled.value = true;
  }
});

watch(
  () => route.query,
  () => {
    refresh();
  }
);
</script>
<template>
  <div class="subscriptions" :class="{ empty: hasNoSubscriptions, loading: $fetchState.pending }">
    <MetaPageHead title="Subscriptions :: ViewTube" description="See your subscription feed" />
    <Spinner v-if="pending" class="centered" />
    <div class="subscribe-info-container">
      <div class="subscribe-info">
        <div class="info">
          <h2>Subscription feed for {{ userStore.username }}</h2>
          <p v-if="lastRefreshTime">
            Last refresh: {{ new Date(lastRefreshTime).toLocaleString() }}
          </p>
        </div>
        <div class="actions">
          <BadgeButton
            class="import-subscriptions-btn"
            :click="() => (subscriptionImportOpen = true)"
          >
            <ImportIcon />
            <p>Import subscriptions</p>
          </BadgeButton>
          <BadgeButton
            class="manage-subscriptions-btn"
            :disabled="hasNoSubscriptions"
            :href="'subscriptions/manage'"
            :internal-link="true"
          >
            <EditIcon />
            <p>Manage</p>
          </BadgeButton>
          <SwitchButton
            v-tippy="getNotificationStatus"
            :value="notificationsEnabled"
            :label="'Enable notifications'"
            :disabled="notificationsBtnDisabled"
            :btnId="'index-btn-1'"
            @valuechange="subscribeToNotifications"
          />
        </div>
      </div>
    </div>
    <div v-if="hasNoSubscriptions && !$fetchState.pending" class="no-subscriptions">
      <SubscriptionIcon />
      <p>No subscriptions yet. Subscribe to a channel to see their latest uploads.</p>
    </div>
    <div class="subscription-videos-container">
      <div
        v-for="(videoSection, index) in getOrderedVideoSections()"
        :key="index"
        class="subscription-section"
      >
        <SectionTitle :title="videoSection.sectionMessage" />
        <div class="section-videos-container">
          <VideoEntry
            v-for="video in videoSection.videos"
            :key="video.videoId"
            :video="video"
            :lazy="false"
          />
        </div>
      </div>
    </div>
    <div
      v-if="getOrderedVideoSections() && getOrderedVideoSections().length > 0"
      class="feed-pagination"
    >
      <Pagination :currentPage="currentPage" :pageCount="pageCount" />
    </div>

    <Teleport to="body">
      <transition name="fade-down">
        <SubscriptionImport
          v-if="subscriptionImportOpen"
          @close="closeSubscriptionImport"
          @done="onSubscriptionImportDone"
        />
      </transition>
    </Teleport>
  </div>
</template>

<style lang="scss">
.subscriptions {
  .spinner {
    z-index: 11;
  }

  &.empty,
  &.loading {
    height: 100vh;
  }
  .section-title {
    width: 100%;
    max-width: $main-width;
    margin: 0 auto;
    padding: 0 10px;
    box-sizing: border-box;

    .manage-btn-container {
      width: auto;
      position: absolute;
      right: 0;
      z-index: 11;
      height: 80px;
      display: grid;
      padding: 0 15px 0 0;
      display: flex;
      flex-direction: row;

      .badge-btn {
        margin: auto auto auto 10px;
      }
    }
  }

  .subscribe-info-container {
    position: relative;
    width: 100%;
    max-width: $main-width;
    margin: 30px auto 0 auto;
    padding: 0 10px;
    z-index: 11;
    box-sizing: border-box;

    .subscribe-info {
      display: flex;
      flex-direction: row;
      padding: 15px;
      box-sizing: border-box;
      background: var(--bgcolor-alt);
      justify-content: space-between;
      border-radius: 5px;
      box-shadow: $medium-shadow;
      box-sizing: border-box;

      @media screen and (max-width: 1000px) {
        flex-direction: column;

        .actions {
          margin: 10px 0 0 0;
        }
      }

      .info {
        display: flex;
        flex-direction: column;
      }

      .actions {
        display: flex;
        flex-direction: row;
        align-items: flex-start;

        @media screen and (max-width: $mobile-width) {
          flex-direction: column;
        }

        .switch {
          margin: 5px 0 0 0 !important;
        }
      }
    }
  }

  .no-subscriptions {
    position: relative;
    z-index: 10;
    margin: 20% 0 0 0;
    text-align: center;
  }

  .subscription-videos-container {
    .subscription-section {
      .section-videos-container {
        width: 100%;
        max-width: $main-width;
        margin: 0 auto;
        padding: 0 10px;
        box-sizing: border-box;
        z-index: 10;
        @include viewtube-grid;

        @media screen and (max-width: $mobile-width) {
          flex-direction: column;
        }
      }
    }
  }

  .feed-pagination {
    display: block;
    position: relative;
    z-index: 11;
    margin: 0 0 30px 0;
  }
}
</style>
